/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  v2306                                 |
|   \\  /    A nd           | Website:  www.openfoam.com                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      snappyHexMeshDict;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

// Which of the steps to run
castellatedMesh true;
snap            true;
addLayers       false;

// Geometry. Definition of all surfaces. All surfaces are of class
// searchableSurface.
// Surfaces are used
// - to specify refinement for any mesh cell intersecting it
// - to specify refinement for any mesh cell inside/outside/near
// - to 'snap' the mesh boundary to the surface
geometry
{
    initial_struct.stl
    {
        type triSurfaceMesh;
        name initial_struct;
    }

    // Define a box for mesh refinement
    refinementBox
    {
        type searchableBox;
        min (-500 -500 -500);  // Adjust these coordinates as needed
        max (500 500 500);     // Adjust these coordinates as needed
    }
}

// Settings for the castellatedMesh generation.
castellatedMeshControls
{
    // Refinement parameters
    // ~~~~~~~~~~~~~~~~~~~~~

    // Maximum number of cells per processor during refinement
    maxLocalCells 20000;

    // Overall cell limit during refinement (if distributed, per processor)
    maxGlobalCells 2000000;

    // Surface refinement
    // ~~~~~~~~~~~~~~~~~~

    // The minimum and maximum refinement level used for the first layer
    // of refinement. A refinement level of 0 is the mesh as defined in
    // blockMeshDict. Refinement levels are levels of uniform refinement.
    minRefinementCells 10;
    maxRefinementCells 100000;

    // Number of buffer layers between different levels.
    // 1 means no buffer layers.
    nCellsBetweenLevels 2;

    // Add the missing parameter here
    resolveFeatureAngle 30;  // Angle in degrees to identify features for refinement
    
    // Explicit feature edge refinement
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // Specifies a level for any cell intersected by explicitly provided
    // edges.
    // These are the features from
    // featureEdgeMesh, which is a set of edge meshes in constant/triSurface
    features
    (
        {
            file "initial_struct.eMesh";
            level 2;
        }
    );

    // Surface based refinement
    // ~~~~~~~~~~~~~~~~~~~~~~~~

    // Surface-wise min and max refinement level
    refinementSurfaces
    {
        initial_struct
        {
            // Surface-wise min and max refinement level
            level (1 4);
        }
    }

    // Region-wise refinement
    // ~~~~~~~~~~~~~~~~~~~~~~

    // Specifies refinement level for cells in relation to a surface. One of
    // three modes
    // - distance. 'levels' specifies per distance to the surface the
    //   wanted refinement level. The distances need to be specified in
    //   descending order.
    // - inside. 'levels' is only one entry and only the level is used. All
    //   cells inside the surface get refined up to the level. The surface
    //   needs to be closed for this to be possible.
    // - outside. Same but cells outside.
    refinementRegions
    {
        refinementBox
        {
            mode inside;
            levels ((1.0 2));
        }
    }

    // Mesh selection
    // ~~~~~~~~~~~~~~

    // After refinement patches get added for all refinementSurfaces and
    // all cells intersecting the surfaces get put into these patches. The
    // section reachable from the locationInMesh is kept.
    // NOTE: This point should be inside the region to be meshed.
    // This is often the most difficult part to get right.
    locationInMesh (100 100 100);  // Changed from (0 0 0) to a point clearly inside the domain

    // Whether any faceZones (as specified in the refinementSurfaces)
    // are only on the boundary of corresponding cellZones or also allow
    // free-standing zone faces. Not used if there are no faceZones.
    allowFreeStandingZoneFaces true;
}

// Add mesh quality controls section
meshQualityControls
{
    // Triangle twist (default -1: accept all)
    minTriangleTwist -1;

    // Other common quality parameters
    maxNonOrtho 65;        // Maximum non-orthogonality
    minTetQuality 1e-15;   // Minimum tet quality
    maxConcave 80;         // Maximum concaveness
    minVol 1e-13;          // Minimum cell volume
    minArea -1;            // Minimum face area
}

// Settings for the snapping.
snapControls
{
    // Number of patch smoothing iterations before finding correspondence
    // to surface
    nSmoothPatch 3;

    // Maximum relative distance for points to be attracted by surface.
    // True distance is this factor times local maximum edge length.
    // Note: changed(corrected) w.r.t 17x! (17x used 2* tolerance)
    tolerance 2.0;

    // Number of mesh displacement relaxation iterations.
    nSolveIter 30;

    // Maximum number of snapping relaxation iterations. Should stop
    // before upon reaching a correct mesh.
    nRelaxIter 5;

    // Feature snapping

    // Number of feature edge snapping iterations.
    // Leave out altogether to disable.
    nFeatureSnapIter 10;

    // Detect (geometric) features by sampling the surface
    implicitFeatureSnap false;

    // Use castellatedMeshControls::features
    explicitFeatureSnap true;

    // Detect features between multiple surfaces
    // (only for explicitFeatureSnap, default = false)
    multiRegionFeatureSnap false;
}

// Settings for the layer addition.
addLayersControls
{
    // Are the thickness parameters below relative to the undistorted
    // size of the refined cell outside layer (true) or absolute sizes (false).
    relativeSizes true;

    // Per final patch (so not geometry!) the layer information
    layers
    {
        "initial_struct.*"
        {
            nSurfaceLayers 3;
        }
    }

    // Expansion factor for layer mesh
    expansionRatio 1.0;

    // Wanted thickness of final added cell layer. If multiple layers
    // is the thickness of the layer furthest away from the wall.
    // Relative to undistorted size of cell outside layer.
    // See relativeSizes parameter.
    finalLayerThickness 0.3;

    // Minimum thickness of cell layer. If for any reason layer
    // cannot be above minThickness do not add layer.
    // If points get not extruded do nGrow layers of connected faces that are
    // also not grown. This helps convergence of the layer addition process
    // close to features.
    nGrow 0;

    // Advanced settings

    // When not to extrude surface. 0 is flat surface, 90 is when two faces
    // make straight angle.
    featureAngle 60;

    // Maximum number of snapping relaxation iterations. Should stop
    // before upon reaching a correct mesh.
    nRelaxIter 5;

    // Number of smoothing iterations of surface normals
    nSmoothSurfaceNormals 1;

    // Number of smoothing iterations of interior mesh movement direction
    nSmoothNormals 3;

    // Smooth layer thickness over surface patches
    nSmoothThickness 10;

    // Stop layer growth on highly warped cells
    maxFaceThicknessRatio 0.5;

    // Reduce layer growth where ratio thickness to medial
    // distance is large
    maxThicknessToMedialRatio 0.3;

    // Angle used to pick up medial axis points
    minMedialAxisAngle 90;

    // Create buffer region for new layer terminations
    nBufferCellsNoExtrude 0;

    // Overall max number of layer addition iterations. The mesher will exit
    // if it reaches this number of iterations; possibly with an illegal
    // mesh.
    nLayerIter 50;

    // Max number of iterations after which relaxed meshQuality controls
    // get used. Up to nRelaxIter it uses the settings in meshQualityControls,
    // after nRelaxIter it uses the values in meshQualityControls::relaxed.
    nRelaxedIter 20;
}

// Mesh quality controls
meshQualityControls
{
    // Maximum non-orthogonality allowed
    maxNonOrtho 65;

    // Max skewness allowed
    maxBoundarySkewness 20;
    maxInternalSkewness 4;

    // Max concaveness allowed
    maxConcave 80;

    // Minimum pyramid volume relative to cell size
    minVol 1e-13;

    // Minimum face area relative to cell size
    minArea -1;

    // Minimum face twist
    minTwist 0.02;

    // Minimum normalized cell determinant
    minDeterminant 0.001;

    // Min and max face flatness (1 = flat, 0 = not flat)
    minFaceWeight 0.02;
    maxFaceWeight 100;

    // Minimum volume ratio of connected cells
    minVolRatio 0.01;

    // Min and max tetrahedral quality (1 = regular, 0 = bad)
    minTetQuality 1e-30;
    maxTetQuality 1;

    // Add the missing nSmoothScale parameter here
    nSmoothScale 4;

    // Relative volume for cells to be ignored
    minVolCollapseRatio 0.1;

    // Smooth mesh on final iteration only
    nRelaxIter 5;
    
    // Optional: error reduction parameters
    errorReduction 0.75;
}

// Advanced

// Flags for optional output
// 0 : only write final meshes
// 1 : write intermediate meshes
// 2 : write volScalarField with cellLevel for postprocessing
// 4 : write current intersections as .obj files
debug 0;

// Merge tolerance. Is fraction of overall bounding box of initial mesh.
// Note: the write tolerance needs to be higher than this.
mergeTolerance 1e-6;

// ************************************************************************* //